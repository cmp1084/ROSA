%% LyX 1.6.4 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage{avant}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{babel}

\usepackage{framed}
\usepackage[unicode=true, 
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{pdftitle={ROSA Appendix},
 pdfauthor={Marcus Jansson}}
 \begin{document}

\section{Expansion of ROSA}


\subsection{More about context switching}

There are two methods for context switching in the ROSA kernel.
\begin{enumerate}
\item Voluntary context switch from a task (cooperative mode).
\item Timer interrupts (preemptive mode).
\end{enumerate}
Cooperative and preemptive modes can be used simultaneously in ROSA.


\subsection{Context switch}

A cooperative, voluntary context switch is performed by the\emph{
ROSA\_yield()} function call. By this call the task will give up its
remaining CPU time to let other tasks run. Later, when the ROSA scheduler
put the yielding task into RUN mode again, execution continue at the
instruction following\emph{ ROSA\_yield()}.


\subsubsection*{Example:}

%
\begin{framed}%

\begin{lstlisting}[basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4]
void task(void)
{
	...
	while(1) {
		...
		ROSA_yield();   //Voluntary context switch
		...             //Execution continue here
                        //next time this task run.
	}
}
\end{lstlisting}
\end{framed}

\medskip{}



\subsection{Timer interrupts}

Preemptive kernel mode is activated by initiating and starting the
timer interrupts once. The task switches will be automatic until the
timer interrupts are stopped.

ROSA utilizes timer 0 of the AVR32 to generate periodic interrupts.
The periodicity is set during the initialization by the \emph{timerInit()}
function. The timer is started after initialization by the \emph{timerStart()}
function. 

Context switching is performed in the interrupt service routine, \emph{timerISR(),}
using the \emph{contextSwitchFromISR()} function.

\pagebreak{}


\subsubsection*{Example:}

%
\begin{framed}%

\begin{lstlisting}[basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4]
__attribute__((__interrupt__)) void timerISR(void)
{
	int sr;
	volatile avr32_tc_t * tc = &AVR32_TC;
	//Read the timer status register to determine if this is a valid interrupt
	sr = tc->channel[0].sr;
	if(sr & AVR32_TC_CPCS_MASK)
	{
		ROSA_yieldFromISR();
	}
}
\end{lstlisting}
\end{framed}\medskip{}


Imagine we had a way to make a delay in a task. The code could look
like this:

%
\begin{framed}%

\begin{lstlisting}[basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4]
void task(void)
{
	...
	while(1) {
		...
		ROSA_sysTickWait(10);    //Delay 10 ticks
		...
	}
}
\end{lstlisting}
\end{framed}\medskip{}



\subsection{Tick?}

What is a tick? A tick is closely related to timer interrupts, which
are generated by a timer circuit inside the MCU. When an interrupt
happens an interrupt service routine (ISR) is run. The ISR increase
the system time by one {}``tick''. Thereafter it checks if there
are any tasks which should be activated, i.e. the tasks which have
previously been waiting but want to run now. For a real time system,
1 ms usually is a good period between ticks. This is often called
\emph{system tick}, or \emph{sysTick }for short. In ROSA it would
be appropriate to call the function\emph{ ROSA\_sysTickWait()}.


\subsection{ROSA\_sysTickWait()}

The delay function work according to the following:
\begin{itemize}
\item Link the executing task into a DELAY queue.
\item Link out a task from the READY queue.
\item Call the scheduler to see which task should begin execute.
\end{itemize}
As we can see this require a number of queues to handle the DELAY.
At least one queue for all waiting tasks and one queue for the tasks
which are ready.

None of this is yet implemented in ROSA.
\end{document}
