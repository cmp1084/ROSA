#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans avant
\font_typewriter default
\font_default_family sfdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "ROSA - Real time Operating System for AVR32"
\pdf_author "Marcus Jansson"
\pdf_subject "Real time RTOS AVR32"
\pdf_keywords "Real time RTOS AVR32"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2.8cm
\topmargin 3.4cm
\rightmargin 2.8cm
\bottommargin 3.2cm
\headheight 3cm
\headsep 1.2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
ROSA
\end_layout

\begin_layout Author
Marcus Jansson <mjansson256@yahoo.se>
\end_layout

\begin_layout LyX-Code
\align center

\size larger
A tiny
\end_layout

\begin_layout LyX-Code
\align center

\size larger
Real time Operating System for AVR32
\end_layout

\begin_layout LyX-Code
\align center
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Description
\end_layout

\begin_layout Standard
ROSA is a small cooperative real time kernel for AVR32 UC3A processors.
 It is aimed to be used on the Atmel EVK1100 platform.
\end_layout

\begin_layout Standard
This document is a description of ROSA's support for pseudo parallel execution
 of user programs.
 By 
\begin_inset Quotes eld
\end_inset

pseudo parallel
\begin_inset Quotes erd
\end_inset

 we mean it 
\begin_inset Quotes eld
\end_inset

seems
\begin_inset Quotes erd
\end_inset

 like the programs work in parallel.
 But as the UC3A processor is a single core processor, only one program
 at a time can be executed.
 
\end_layout

\begin_layout Standard
A small operating system like ROSA can be used to enhance the structure
 of a complex program.
 This is done by breaking down the complex program into several smaller
 programs.
\end_layout

\begin_layout Standard
Compared to other light weight kernels, ROSA is a tiny kernel with very
 limited functionality.
 
\end_layout

\begin_layout Subsection
Hardware
\end_layout

\begin_layout Standard
ROSA runs on the EVK1100 platform.
 Among other things the hardware features 512 kB flash memory, 64 kB internal
 RAM memory, a 12 Mhz external crystal, user LEDs, user buttons, serial
 communication etc.
\end_layout

\begin_layout Subsubsection
I/O drivers
\end_layout

\begin_layout Standard
ROSAs I/O drivers support the following hardware functions on EVK1100:
\end_layout

\begin_layout Itemize
LEDs.
\end_layout

\begin_layout Itemize
Buttons.
\end_layout

\begin_layout Itemize
Mini-joystick.
\end_layout

\begin_layout Itemize
Potentiometer.
\end_layout

\begin_layout Itemize
Serial ports.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Subsubsection
ROSA source code
\end_layout

\begin_layout Standard
The ROSA source code is available in the rosa/src directory which makes
 it possible to expand ROSA with more services.
 Examples of expansions that can be done:
\end_layout

\begin_layout Itemize
Support for time sharing.
\end_layout

\begin_layout Itemize
Support for priority driven scheduling.
\end_layout

\begin_layout Itemize
Support for communication mechanisms, semaphores, monitors, mailboxes and
 rendez-vouz.
\end_layout

\begin_layout Itemize
...
\end_layout

\begin_layout Subsubsection
Directory structure
\end_layout

\begin_layout Standard
The ROSA software consists of the following directories and files:
\end_layout

\begin_layout Itemize
rosa/
\end_layout

\begin_deeper
\begin_layout Itemize
bin/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Destination for the binary files.
\end_layout

\begin_layout Itemize
cpu/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- The startup and linker scripts.
\end_layout

\begin_layout Itemize
doc/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Documentation about ROSA.
\end_layout

\begin_layout Itemize
include/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- The header file directory.
\end_layout

\begin_deeper
\begin_layout Itemize
drivers/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Header files for the drivers.
\end_layout

\begin_layout Itemize
kernel/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Header files for the kernel.
\end_layout

\end_deeper
\begin_layout Itemize
src/ 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- The source file directory.
\end_layout

\begin_deeper
\begin_layout Itemize
main.c 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- The main program for ROSA.
\end_layout

\begin_layout Itemize
rosa_config.h 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- User configuration of ROSA.
\end_layout

\begin_layout Itemize
kernel/
\begin_inset space \hfill{}
\end_inset

- Kernel source directory.
\end_layout

\begin_deeper
\begin_layout Itemize
rosa_ker.c 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Kernel C source.
\end_layout

\begin_layout Itemize
rosa_ker_asm.S 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Kernel assembler source.
\end_layout

\begin_layout Itemize
rosa_scheduler.c
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Scheduler specific source.
 
\end_layout

\begin_layout Itemize
rosa_int.c
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Interrupt specific source.
\end_layout

\begin_layout Itemize
rosa_int_asm.S
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Interrupt assembler source.
\end_layout

\begin_layout Itemize
rosa_tim.c
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Timer specific soruce.
\end_layout

\begin_layout Itemize
rosa_tim_asm.S 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Timer assembler source.
\end_layout

\end_deeper
\begin_layout Itemize
drivers/
\end_layout

\begin_deeper
\begin_layout Itemize
button.c 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Push button driver.
\end_layout

\begin_layout Itemize
delay.c
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Delay functions.
\end_layout

\begin_layout Itemize
gpio.c 
\begin_inset space \hfill{}
\end_inset

- GPIO driver.
\end_layout

\begin_layout Itemize
led.c 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- LED driver.
\end_layout

\begin_layout Itemize
pot.S 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Potentiometer driver.
\end_layout

\begin_layout Itemize
usart.c 
\begin_inset space \qquad{}
\end_inset


\begin_inset space \hfill{}
\end_inset

- Serial communication driver.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Makefile 
\begin_inset space \hfill{}
\end_inset

- Script for the 'make' program.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
How to compile ROSA
\end_layout

\begin_layout Subsubsection
make
\end_layout

\begin_layout Standard
ROSA can be cross compiled by using the GNU 'make' command from the rosa/
 directory on a *nix-like system with the avr32 GNU toolchain properly installed.
 Simply compile ROSA by typing:
\end_layout

\begin_layout LyX-Code
make
\end_layout

\begin_layout Standard
in the rosa/ directory.
 A binary file, which can be programmed onto the EVK1100, is produced in
 the rosa/bin/ directory.
\end_layout

\begin_layout Subsubsection
AVR32 Studio
\end_layout

\begin_layout Standard
AVR32 Studio can be used to compile ROSA.
 First the ROSA project must be set up properly.
 This is done by creating a new Make Project (Main menu File/New/Project...)
 and importing the rosa/ directory into AVR32 Studio.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection
How to program ROSA 
\begin_inset Newline newline
\end_inset

onto the EVK1100
\end_layout

\begin_layout Subsubsection
make
\end_layout

\begin_layout Standard
After a successful compile, ROSA can be programmed by the Dragon JTAG debugger
 onto the EVK1100 MCU flash memory by typing:
\end_layout

\begin_layout LyX-Code
make program
\end_layout

\begin_layout Standard
in the rosa/ directory.
 
\end_layout

\begin_layout Subsubsection
AVR32 Studio
\end_layout

\begin_layout Standard
AVR32 Studio can also be used for programming the MCU flash by the normal
 procedure.
\end_layout

\begin_layout Section
ROSA kernel functionality
\end_layout

\begin_layout Standard
This is a brief description of the kernel functionality.
\end_layout

\begin_layout Subsection
Kernel
\end_layout

\begin_layout Standard
The ROSA kernel is the controller software and supervisor of the system.
 As a user of ROSA you create and install 
\begin_inset Quotes eld
\end_inset

tasks
\begin_inset Quotes erd
\end_inset

 into the ROSA kernel.
 When ROSA is started one of the tasks is picked up and execution is turned
 over to this task.
\end_layout

\begin_layout Standard
From time to time the task needs to give up its execution and let other
 tasks run.
 The kernel perform a task context switch, thus allowing the next waiting
 task to run.
\end_layout

\begin_layout Subsubsection
Kernel functions
\end_layout

\begin_layout Standard
All kernel functions that the user can call are prefixed 
\emph on
ROSA_
\emph default
, e.g.
 
\emph on
ROSA_scheduler().
\end_layout

\begin_layout Standard
Part of the ROSA kernel is written in assembler.
 In order to be able to share the same TCB structure from both assemebler
 and C the kernel utilizes offsets found in the file rosa/src/include/kernel/ros
a_off.i.
 These offsets are used by the assembler routines to access the elements
 in the TCB block.
\end_layout

\begin_layout Subsubsection
Kernel configuration
\end_layout

\begin_layout Standard
A few user configurations can be done through the 
\emph on
rosa_config.h
\emph default
 file.
 For example the USART baudrate is defined here.
 The default is 57600 baud.
\end_layout

\begin_layout Subsection
Task
\end_layout

\begin_layout Standard
A task is a program running under the kernels supervision.
 A task consists of:
\end_layout

\begin_layout Itemize
A TCB.
\end_layout

\begin_layout Itemize
A data area.
\end_layout

\begin_layout Itemize
Program code.
\end_layout

\begin_layout Subsubsection
TCB
\end_layout

\begin_layout Standard
The TCB contain information and/or space for:
\end_layout

\begin_layout Itemize
Task identification (id/name).
\end_layout

\begin_layout Itemize
Address to the next TCB in the TCB-list.
\end_layout

\begin_layout Itemize
The start address of the task.
\end_layout

\begin_layout Itemize
Where the data area is located and its size.
\end_layout

\begin_layout Itemize
The current state, which is described by the return address and the status
 register (SR).
\end_layout

\begin_layout Itemize
All necessary CPU registers.
\end_layout

\begin_layout Standard
The exact definition of the TCB is found in the file rosa/src/include/kernel/ros
a_def.h.
\end_layout

\begin_layout Subsubsection
Data area
\end_layout

\begin_layout Standard
The data area is the private stack for the task.
 The data area contains temporary data etc.
 for the task.
 The stack size must be suitable to hold all temporary data.
 
\end_layout

\begin_layout Subsubsection
Program code
\end_layout

\begin_layout Standard
One of the important parts in a task is the program code.
 When the kernel does a context switch the task program code starts to run.
 The program code is executed in a never ending loop.
 From time to time the program code call the kernel context switch function
 in order to allow other tasks to run.
\end_layout

\begin_layout Subsection
TCBLIST
\end_layout

\begin_layout Standard
The ROSA kernel utilizes a variable TCBLIST which contain a link to the
 TCBs in the kernel.
 See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Figure1tcblist"

\end_inset

.
 Another variable EXECTASK contains the TCB of the current executing task.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TCBLIST is a circular linked list.
\begin_inset Newline newline
\end_inset


\begin_inset Index
status open

\begin_layout Plain Layout
Figure1tcblist
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Figure1tcblist"

\end_inset


\begin_inset Graphics
	filename pic/tcblist.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The internal structure of ROSA
\end_layout

\begin_layout Standard
This is a more detailed description of the internal structure of ROSA.
\end_layout

\begin_layout Standard
The first thing to note about ROSA is that kernel functions execute in superviso
r mode and the tasks execute in user mode.
 Mode switching is done by ROSA.
\end_layout

\begin_layout Subsection
Creating and installing tasks
\end_layout

\begin_layout Standard
All TCB's are linked together by the variable TCBLIST.
 When a task have been created by 
\emph on
ROSA_tcbCreate()
\emph default
 and installed in the kernel by 
\emph on
ROSA_tcbInstall()
\emph default
, the TCBLIST will contain a reference to the first TCB created.
\end_layout

\begin_layout Standard
When more tasks are created and installed, each TCB is linked into the TCBLIST
 and the correct information is filled into the TCB.
\end_layout

\begin_layout Standard
These are the necessary informations that need to be initialized in the
 TCB:
\end_layout

\begin_layout Itemize
How to find the next TCB.
\end_layout

\begin_layout Itemize
Start and return address, the address the task will start execute at.
\end_layout

\begin_layout Itemize
The status register (SR) is set to work in user mode.
\end_layout

\begin_layout Itemize
The user stack pointer (USP), which the task will use.
\end_layout

\begin_layout Itemize
All CPU registers are saved into the TCB in order to not be destroyed by
 a context switch.
\end_layout

\begin_layout Standard
Part of this needs to be done in assembler, due to the low level nature
 of e.g.
 saving specific CPU registers.
 This is handled by the 
\emph on
ROSA_contextInit()
\emph default
 call last in 
\emph on
ROSA_tcbCreate()
\emph default
.
\end_layout

\begin_layout Subsection
Starting the ROSA kernel
\end_layout

\begin_layout Standard
When 
\emph on
ROSA_start()
\emph default
 is called the first task in TCBLIST will start to execute.
 In order to activate the first task we must load the correct value for
 the user stack pointer (USP), and set the correct value of the status register
 (SR).
 This needs to be done from assembler.
\end_layout

\begin_layout Standard
To start task execution the task start address, STADDR, is loaded from the
 TCB and a jump is done to STADDR.
 
\end_layout

\begin_layout Subsection
Context switching
\end_layout

\begin_layout Standard
When a task have finished its execution during a period, 
\emph on
ROSA_contextSwitch()
\emph default
 is called.
 
\emph on
ROSA_contextSwitch() 
\emph default
performs the following sequence:
\end_layout

\begin_layout Itemize
The context of the CPU is stored to the TCB.
\end_layout

\begin_layout Itemize
The scheduler, 
\emph on
ROSA_scheduler()
\emph default
, is called and the currently running TCB, referenced to by the variable
 EXECTASK, is changed to another TCB from the TCBLIST.
\end_layout

\begin_layout Itemize
The context of the new TCB is restored by a call to
\begin_inset Newline newline
\end_inset

 
\emph on
ROSA_contextRestore()
\emph default
.
\end_layout

\begin_layout Standard
The 
\emph on
ROSA_contextSwitch() 
\emph default
utilizes the supervisor mode which is entered by the '
\emph on
scall
\emph default
' instruction.
 This instruction jumps to the 
\emph on
_handle_Supervisor_Call
\emph default
 vector and effectively runs the context switch routines in supervisor mode.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The context switch procedure
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename pic/contextSwitch.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Context save
\end_layout

\begin_layout Standard

\emph on
_ROSA_contextSave()
\emph default
 does the following operations:
\end_layout

\begin_layout Itemize
Fetch the TCB of the current executing task.
\end_layout

\begin_layout Itemize
Saves temporary work registers.
\end_layout

\begin_layout Itemize
Saves the status register, SR.
\end_layout

\begin_layout Itemize
Saves the CPU registers.
\end_layout

\begin_layout Itemize
Saves the return address.
\end_layout

\begin_layout Itemize
Saves the correct user stack pointer, USP.
\end_layout

\begin_layout Subsubsection
Scheduling
\end_layout

\begin_layout Standard
The 
\emph on
ROSA_scheduler()
\emph default
 function fetch the next task to execute.
 A reference to the task TCB is put in the EXECTASK variable.
 
\end_layout

\begin_layout Subsubsection
Context restore
\end_layout

\begin_layout Standard

\emph on
_ROSA_contextRestore()
\emph default
 practically does the reverse of the context save:
\end_layout

\begin_layout Itemize
Fetch the TCB from the EXECTASK.
\end_layout

\begin_layout Itemize
Restores the USP.
\end_layout

\begin_layout Itemize
Restores return address.
\end_layout

\begin_layout Itemize
Restores CPU registers.
\end_layout

\begin_layout Itemize
Restores SR.
\end_layout

\begin_layout Itemize
Restores work registers.
\end_layout

\begin_layout Standard
This sequence makes the CPU start executing the new task.
\end_layout

\begin_layout Section
How to use ROSA from C
\end_layout

\begin_layout Standard
We will look at how ROSA can be used.
 The following code contains two simple tasks and initialization of ROSA.
 Each task will control LED1 and LED2 on the EVK1100.
\end_layout

\begin_layout Subsection
Simple source code walk through
\end_layout

\begin_layout Standard
This is a description on how to set up the main.c file and start running
 the ROSA kernel.
 A more detailed walk through of the kernel is found in section 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Kernel-source-code"

\end_inset


\end_layout

\begin_layout Subsubsection
Headers
\end_layout

\begin_layout Standard
We start in the main.c by including the necessary header files.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

//Kernel includes
\end_layout

\begin_layout Plain Layout

#include "kernel/rosa_ker.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//I/O driver includes
\end_layout

\begin_layout Plain Layout

#include "drivers/led.h"
\end_layout

\begin_layout Plain Layout

#include "drivers/delay.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Include configuration
\end_layout

\begin_layout Plain Layout

#include "rosa_config.h"
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tasks
\end_layout

\begin_layout Standard
Now we define our tasks; task1 and task2.
 Note that the tasks consist of a 
\emph on
while(1)
\emph default
-loop, which basically will make the task run forever.
 
\end_layout

\begin_layout Standard
The next thing to note is the 
\emph on
ledOn()/Off()
\emph default
 scheme, task1 will light up LED1 of the EVK1100.
 Task2 will light up LED2.
 Pay attention to the inconsistency between the labeling of the LEDs on
 EVK1100 and the defined LEDx_GPIO numbers.
\end_layout

\begin_layout Standard

\emph on
ROSA_contextSwitch()
\emph default
 is the function which performs a context switch, allowing both tasks to
 run in pseudo parallel, despite the forever 
\emph on
while(1)
\emph default
-loop.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

//TASK1
\end_layout

\begin_layout Plain Layout

//--------------
\end_layout

\begin_layout Plain Layout

//LED1 lights up
\end_layout

\begin_layout Plain Layout

//LED2 goes dark
\end_layout

\begin_layout Plain Layout

void task1(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while(1) {
\end_layout

\begin_layout Plain Layout

		ledOn(LED0_GPIO);	//EVK1100 LED1!
\end_layout

\begin_layout Plain Layout

		ledOff(LED1_GPIO);
\end_layout

\begin_layout Plain Layout

		ROSA_contextSwitch();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//TASK2
\end_layout

\begin_layout Plain Layout

//--------------
\end_layout

\begin_layout Plain Layout

//LED2 lights up
\end_layout

\begin_layout Plain Layout

//LED1 goes dark
\end_layout

\begin_layout Plain Layout

void task2(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while(1) {
\end_layout

\begin_layout Plain Layout

		ledOff(LED0_GPIO);
\end_layout

\begin_layout Plain Layout

		ledOn(LED1_GPIO);
\end_layout

\begin_layout Plain Layout

		ROSA_contextSwitch();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
TCB and stack declaration
\end_layout

\begin_layout Standard
We declare our TCB and stack for the two tasks we are going to create.
 The first thing we do is to reserve stack space by defining a global array
 with appropriate size.
 Space for the TCB is also reserved by the tcb struct.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

//Data blocks for the tasks
\end_layout

\begin_layout Plain Layout

#define T1_STACK_SIZE 0x40
\end_layout

\begin_layout Plain Layout

static int t1_stack[T1_STACK_SIZE];
\end_layout

\begin_layout Plain Layout

static tcb t1_tcb;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define T2_STACK_SIZE 0x40
\end_layout

\begin_layout Plain Layout

static int t2_stack[T2_STACK_SIZE];
\end_layout

\begin_layout Plain Layout

static tcb t2_tcb;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
More TCB and TCBLIST
\end_layout

\begin_layout Standard
So far so good, but ROSA does not know where to find the tasks we want to
 run, and neither are the TCBs of the tasks set up correctly yet.
 This is done by calling 
\emph on
ROSA_tcbCreate()
\emph default
 and 
\emph on
ROSA_tcbInstall().

\emph default
 This must be done before starting ROSA with the 
\emph on
ROSA_start()
\emph default
 call.
 Execution control is now in the hands of ROSA and will not return to this
 point.
\end_layout

\begin_layout Standard
Below is an example of how it is done from the 
\emph on
main()
\emph default
-function:
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	//Initialize ROSA
\end_layout

\begin_layout Plain Layout

	ROSA_init();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Create tasks, set up the TCB correctly
\end_layout

\begin_layout Plain Layout

	ROSA_tcbCreate(&t1_tcb, "tsk1", task1, t1_stack, T1_STACK_SIZE);
\end_layout

\begin_layout Plain Layout

	ROSA_tcbCreate(&t2_tcb, "tsk2", task2, t2_stack, T2_STACK_SIZE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Install the TCBs into the TCBLIST.
\end_layout

\begin_layout Plain Layout

	ROSA_tcbInstall(&t1_tcb);
\end_layout

\begin_layout Plain Layout

	ROSA_tcbInstall(&t2_tcb);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Start the ROSA kernel
\end_layout

\begin_layout Plain Layout

	ROSA_start();
\end_layout

\begin_layout Plain Layout

	/* Execution will never return here */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Compiling
\end_layout

\begin_layout Standard
To compile the ROSA system, enter the rosa/ directory and type:
\end_layout

\begin_layout LyX-Code
make
\end_layout

\begin_layout Standard
to start the compilation.
\end_layout

\begin_layout Subsubsection
Programming
\end_layout

\begin_layout Standard
To program the binary onto the EVK1100, enter the rosa directory and type:
\end_layout

\begin_layout LyX-Code
make program
\end_layout

\begin_layout Standard
When the programming is done the two tasks should start to execute on the
 EVK1100.
\end_layout

\begin_layout Section
Kernel source code walk through
\begin_inset Index
status open

\begin_layout Plain Layout
Kernel source code walk through
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Kernel-source-code"

\end_inset


\end_layout

\begin_layout Standard
This is a closer look at the ROSA kernel.
\end_layout

\begin_layout Standard
In the 
\emph on
main()
\emph default
 function, as shown previously, the first kernel function to be called is
 
\emph on
ROSA_init().
 
\emph default
This function sets the TCBLIST and EXECTASK to NULL.
 This is done since no task have been added yet.
 Also I/O is initialized by this function call.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void ROSA_init(void) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	//No tasks yet.
\end_layout

\begin_layout Plain Layout

	TCBLIST = NULL; 
\end_layout

\begin_layout Plain Layout

	EXECTASK = NULL; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Do initialization of I/O drivers 
\end_layout

\begin_layout Plain Layout

	ledInit();                         //LEDs 
\end_layout

\begin_layout Plain Layout

	buttonInit();                      //Buttons 
\end_layout

\begin_layout Plain Layout

	joystickInit();                    //Joystick 
\end_layout

\begin_layout Plain Layout

	potInit();                         //Potentiometer 
\end_layout

\begin_layout Plain Layout

    usartInit(USART, &usart_options, FOSC0);//Serial
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

Next the TCB's of two tasks are created by function call to 
\emph on
ROSA_tcbCreate()
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

ROSA_tcbCreate(&t1_tcb, "tsk1", task1, t1_stack, T1_STACK_SIZE);
\end_layout

\begin_layout Plain Layout

ROSA_tcbCreate(&t2_tcb, "tsk2", task2, t2_stack, T2_STACK_SIZE);
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

These calls fill in the necessary information into the TCB as shown below.
 First the task id/name is copied into the TCB.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void ROSA_tcbCreate(tcb * tcbTask, char tcbName[NAMESIZE],    void *tcbFunction,
 int * tcbStack, int tcbStackSize) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//Initialize the tcb with the correct values 	
\end_layout

\begin_layout Plain Layout

	for(i = 0; i < NAMESIZE; i++) { 		
\end_layout

\begin_layout Plain Layout

		//Copy the id/name 		
\end_layout

\begin_layout Plain Layout

		tcbTask->id[i] = tcbName[i]; 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

The link to the next TCB is set to NULL as this TCB block have not been
 installed into the ROSA kernel yet.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

	//Dont link this TCB anywhere yet 	
\end_layout

\begin_layout Plain Layout

	tcbTask->nexttcb = NULL;	
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

The start and return addresses are set up to point to the beginning of the
 task function.
 The stack and its size are set up, and the USP is set to point to the data
 area.
 An initial value of the SR is set.
 This give us a known initial state of the task.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

	//Set the task function start and return address 	
\end_layout

\begin_layout Plain Layout

	tcbTask->staddr = tcbFunction; 	
\end_layout

\begin_layout Plain Layout

	tcbTask->retaddr = (int)tcbFunction;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Set up the stack 	
\end_layout

\begin_layout Plain Layout

	tcbTask->datasize = tcbStackSize; 	
\end_layout

\begin_layout Plain Layout

	tcbTask->dataarea = tcbStack + tcbStackSize; 	
\end_layout

\begin_layout Plain Layout

	tcbTask->saveusp = tcbTask->dataarea;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//Set the initial SR 	
\end_layout

\begin_layout Plain Layout

	tcbTask->savesr = ROSA_INITIALSR;
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

The last thing to do during TCB creation is to set up the task context registers
 to a known state.
 This is done in assembler by the
\emph on
 ROSA_context-Init()
\emph default
 call.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

	//Initialize context 	
\end_layout

\begin_layout Plain Layout

	ROSA_contextInit(tcbTask); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

The assembler routine initialize the lr register (task activation record)
 to point to the start address, STADDR, of the task program code.
 The registers in the TCB, TCB.SAVEREG.R0 - TCB.SAVEREG.R12, are set to zero.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

ROSA_contextInit: 	
\end_layout

\begin_layout Plain Layout

	//Initialize lr in the savereg area 	
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.STADDR] 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.LR],r0
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//Initialize regs to zero 	
\end_layout

\begin_layout Plain Layout

	mov r0,0x0 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.R0],r0 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.R1],r0 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.R2],r0 	
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.R12],r0 	
\end_layout

\begin_layout Plain Layout

	mov pc,lr 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Now the TCB have been properly created and it is time to install the TCB
 into the ROSA kernel.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

	//Install TCB into the TCBLIST.
\end_layout

\begin_layout Plain Layout

	ROSA_tcbInstall(t1_tcb); 
\end_layout

\begin_layout Plain Layout

	ROSA_tcbInstall(t2_tcb); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

This function call checks to see if the TCBLIST is empty, which is the case
 when t1_tcb is installed.
 The TCB (t1_tcb) is installed at the first position of the list.
\end_layout

\begin_layout Standard
If the TCBLIST is not empty, which will be the case when t2_tcb is installed,
 the TCB will be attached to the last position in the list.
\end_layout

\begin_layout Standard
The TCBLIST is circular, which mean the last element will always point to
 the first element.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void ROSA_tcbInstall(tcb * tcbTask) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	tcb * tcbTmp;
\end_layout

\begin_layout Plain Layout

	// Is this the first tcb installed? 
\end_layout

\begin_layout Plain Layout

	if(TCBLIST == NULL) {
\end_layout

\begin_layout Plain Layout

		TCBLIST = tcbTask;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		//Install the first tcb
\end_layout

\begin_layout Plain Layout

		TCBLIST->nexttcb = tcbTask;  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		//Make the list circular
\end_layout

\begin_layout Plain Layout

		tcbTask->nexttcb = TCBLIST;  
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	else {
\end_layout

\begin_layout Plain Layout

		//Find last tcb in the list
\end_layout

\begin_layout Plain Layout

		tcbTmp = TCBLIST; 
\end_layout

\begin_layout Plain Layout

		while(tcbTmp->nexttcb != TCBLIST) {
\end_layout

\begin_layout Plain Layout

			tcbTmp = tcbTmp->nexttcb;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		//Install tcb last in the list
\end_layout

\begin_layout Plain Layout

		tcbTmp->nexttcb = tcbTask;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		//Make the list circular
\end_layout

\begin_layout Plain Layout

		tcbTask->nexttcb = TCBLIST;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Finally the ROSA kernel can be started:
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

	//Start the ROSA kernel
\end_layout

\begin_layout Plain Layout

	ROSA_start();
\end_layout

\begin_layout Plain Layout

	/* Execution will never return to here */
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In effect this is the initial context switch.
 This is an assembler routine that sets EXECTASK to be the first task in
 the TCBLIST.
 The routine loads information (USP, SR, STADDR, registers etc.) from EXECTASK
 and puts it directly onto the processor.
\end_layout

\begin_layout Standard
Loading lr with STADDR means that we are going to continue execution at
 the task program code when this routine is finished.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

ROSA_start:
\end_layout

\begin_layout Plain Layout

	//Put the first task from TCBLIST into EXECTASK
\end_layout

\begin_layout Plain Layout

	lda.w r12,TCBLIST
\end_layout

\begin_layout Plain Layout

	lda.w r11,EXECTASK
\end_layout

\begin_layout Plain Layout

	ld.w r12,r12[0x0]
\end_layout

\begin_layout Plain Layout

	st.w r11[0x0],r12
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Set up start USP
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.SAVEUSP]
\end_layout

\begin_layout Plain Layout

	st.w --sp,r0
\end_layout

\begin_layout Plain Layout

	ldmts sp,sp
\end_layout

\begin_layout Plain Layout

	ld.w r0,sp++
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Load start lr, execution will jump here later
\end_layout

\begin_layout Plain Layout

	ld.w lr,r12[TCB.STADDR]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Set up start SR, enter user mode
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.SAVESR]
\end_layout

\begin_layout Plain Layout

	mtsr 0x0,r0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Load start registers R0-R12
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.SAVEREG.R0]
\end_layout

\begin_layout Plain Layout

	ld.w r1,r12[TCB.SAVEREG.R1]
\end_layout

\begin_layout Plain Layout

	ld.w r2,r12[TCB.SAVEREG.R2]
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	ld.w r12,r12[TCB.SAVEREG.R12]
\end_layout

\begin_layout Plain Layout

	mov pc,lr
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Now task1 starts to execute.
 It will light LED1, turn LED2 off and then immediately do a context switch.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void task1(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while(1) {
\end_layout

\begin_layout Plain Layout

		ledOn(LED0_GPIO);	//EVK1100 LED1!
\end_layout

\begin_layout Plain Layout

		ledOff(LED1_GPIO);
\end_layout

\begin_layout Plain Layout

		ROSA_contextSwitch();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

The context switch routine consists of switching to supervisor mode and
 three calls to 
\emph on
_ROSA_contextSave(), ROSA_scheduler() 
\emph default
and
\begin_inset Newline newline
\end_inset

 
\emph on
_ROSA_contextRestore()
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

ROSA_contextSwitch:
\end_layout

\begin_layout Plain Layout

	pushm lr
\end_layout

\begin_layout Plain Layout

	lda.w lr,_ROSA_contextSwitch
\end_layout

\begin_layout Plain Layout

	//Enter supervisor mode
\end_layout

\begin_layout Plain Layout

	scall 
\end_layout

\begin_layout Plain Layout

_ROSA_contextSwitch:
\end_layout

\begin_layout Plain Layout

	call _ROSA_contextSave
\end_layout

\begin_layout Plain Layout

	call ROSA_scheduler
\end_layout

\begin_layout Plain Layout

	call _ROSA_contextRestore 
\end_layout

\begin_layout Plain Layout

	//Execution will not return to here!
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
_ROSA_contextSave()
\emph default
 routine saves the context from the processor into the TCB of EXECTASK.
 Note that at this point the USP is one element off, caused by the call
 to the 
\emph on
ROSA_contextSwitch()
\emph default
.
 This is due to the fact that we need to push the lr to the stack before
 entering supervisor mode.
 A stack correction is made at the end of 
\emph on
_ROSA_contextSave()
\emph default
 to allow the task to continue its execution in the task program code next
 time it is activated.
 
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

_ROSA_contextSave:
\end_layout

\begin_layout Plain Layout

	pushm r12
\end_layout

\begin_layout Plain Layout

	//Fetch the current executing task
\end_layout

\begin_layout Plain Layout

	lda.w r12,EXECTASK
\end_layout

\begin_layout Plain Layout

	ld.w r12,r12[0x0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save work registers to TCB
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVER0],r0
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVER1],r1
\end_layout

\begin_layout Plain Layout

	ld.w r0,sp++            	//Use r0 to save r12
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.R12],r0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save task SR to TCB
\end_layout

\begin_layout Plain Layout

	ld.w r0,sp[SF_SR]
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVESR],r0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save task registers r0-r11 to TCB
\end_layout

\begin_layout Plain Layout

	mov r0,TCB.SAVEREG.R11
\end_layout

\begin_layout Plain Layout

	add r0,r12 
\end_layout

\begin_layout Plain Layout

	stmts r0,r0-r11
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Get the address of the USP
\end_layout

\begin_layout Plain Layout

	mov r0,sp
\end_layout

\begin_layout Plain Layout

	st.w --sp,r0
\end_layout

\begin_layout Plain Layout

	stmts sp,sp
\end_layout

\begin_layout Plain Layout

	ld.w r1,sp++	//USP in r1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save RETADDR to TCB
\end_layout

\begin_layout Plain Layout

	ld.w r0,r1[SF_LR_TASK]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Get from user stack, return to task, 
\end_layout

\begin_layout Plain Layout

	//not to contextSwitch 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.RETADDR],r0 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save LR_task 	
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEREG.LR],r0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Correct the USP for the ROSA_contextSwitch() 
\end_layout

\begin_layout Plain Layout

	//call.
 This is done since we do not want to 
\end_layout

\begin_layout Plain Layout

	//return to ROSA_contextSwitch(), where the stack 
\end_layout

\begin_layout Plain Layout

	//frame is currently at but to the executing task
\end_layout

\begin_layout Plain Layout

	sub r1,-0x04
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Save USP
\end_layout

\begin_layout Plain Layout

	st.w r12[TCB.SAVEUSP],r1
\end_layout

\begin_layout Plain Layout

	mov pc,lr 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset

When the scheduler is done a new task TCB is present in the EXECTASK.
 Now 
\emph on
_ROSA_contextRestore()
\emph default
 will do the final part of the context switch, i.e.
 turning execution over to the next task.
 Register values are fetched from the TCB and written directly to the processor
 or on the stack for retrieval when exiting supervisor mode.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

_ROSA_contextRestore:
\end_layout

\begin_layout Plain Layout

	//Fetch the current executing task
\end_layout

\begin_layout Plain Layout

	lda.w r12,EXECTASK
\end_layout

\begin_layout Plain Layout

	ld.w r12,r12[0x0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore USP
\end_layout

\begin_layout Plain Layout

	ld.w r1,r12[TCB.SAVEUSP]
\end_layout

\begin_layout Plain Layout

	st.w --sp,r1
\end_layout

\begin_layout Plain Layout

	ldmts sp,sp
\end_layout

\begin_layout Plain Layout

	ld.w r1,sp++
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore LR = retaddr
\end_layout

\begin_layout Plain Layout

	ld.w lr,r12[TCB.SAVEREG.LR]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore RETADDR
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.RETADDR]
\end_layout

\begin_layout Plain Layout

	st.w sp[SF_PC],r0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore registers
\end_layout

\begin_layout Plain Layout

	mov r0,TCB.SAVEREG.R11 	
\end_layout

\begin_layout Plain Layout

	add r0,r12
\end_layout

\begin_layout Plain Layout

	ldmts r0,r0-r11
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore r7
\end_layout

\begin_layout Plain Layout

	ld.w r7,r12[TCB.SAVEREG.R7]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore SR 	
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.SAVESR]
\end_layout

\begin_layout Plain Layout

	st.w sp[SF_SR],r0			//Put SR on the stack for later fetch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Restore work registers 	
\end_layout

\begin_layout Plain Layout

	ld.w r0,r12[TCB.SAVER0]
\end_layout

\begin_layout Plain Layout

	ld.w r1,r12[TCB.SAVER1]
\end_layout

\begin_layout Plain Layout

	ld.w r12,r12[TCB.SAVEREG.R12]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//We are done, exit from supervisor mode
\end_layout

\begin_layout Plain Layout

	rets
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Now execution is at task2, which will run until the 
\emph on
ROSA_contextSwitch()
\emph default
 turn over execution to the next task, which in this case is task1.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void task2(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while(1) {
\end_layout

\begin_layout Plain Layout

		ledOff(LED0_GPIO);	//EVK1100 LED1!
\end_layout

\begin_layout Plain Layout

		ledOn(LED1_GPIO);
\end_layout

\begin_layout Plain Layout

		ROSA_contextSwitch();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The two tasks will continue to execute in this fashion, taking turn to run
 their program code on the processor one loop at a time before leaving execution
 over to the other task by the 
\emph on
ROSA_contextSwitch()
\emph default
 call.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
We now know what parts are necessary to a small cooperative realtime kernel.
 We have seen in detail how a simple system execute on the ROSA kernel.
\end_layout

\end_body
\end_document
